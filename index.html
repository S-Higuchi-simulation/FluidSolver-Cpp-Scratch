<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>一次元熱伝導シミュレーション</title>

    <!-- MathJax -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [["$$", "$$"]],
        },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

    <style>
      body {
        font-family: "Helvetica", "Arial", sans-serif;
        background: #f5f5f5;
        margin: 0;
        line-height: 1.7;
      }

      main {
        max-width: 900px;
        margin: auto;
        padding: 40px;
        background: white;
      }

      h1,
      h2 {
        border-bottom: 2px solid #ddd;
        padding-bottom: 5px;
      }

      section {
        margin-bottom: 40px;
      }

      canvas {
        display: block;
        margin: 20px auto;
        background: black;
      }

      .control {
        text-align: center;
        margin-bottom: 20px;
      }
    </style>
  </head>

  <body>
    <main>
      <h1>一次元熱伝導方程式の数値シミュレーション</h1>

      <section>
        <h2>1. 一次元熱伝導方程式</h2>

        <p>
          一次元空間 $x$ における温度分布 $T(x,t)$
          は、熱が拡散によって伝わる場合、 次の
          <strong>一次元熱伝導方程式</strong> に従う。
        </p>

        $$ \frac{\partial T}{\partial t} = \alpha \frac{\partial^2 T}{\partial
        x^2} $$

        <p>
          ここで $\alpha$ は <strong>熱拡散係数</strong> であり、
          熱がどれだけ速く広がるかを表す。
        </p>
      </section>

      <section>
        <h2>2. 空間と時間の離散化</h2>

        <p>
          数値計算では、連続な空間と時間を格子点に分割する。 長さ $L$ の区間を
          $N$ 点に分割すると、空間刻み幅は
        </p>

        $$ \Delta x = \frac{L}{N-1} $$

        <p>時間も同様に刻み幅 $\Delta t$ で離散化する。</p>
      </section>

      <section>
        <h2>3. 差分近似</h2>

        <h3>時間微分（前進差分）</h3>

        $$ \frac{\partial T}{\partial t} \approx \frac{T_i^{n+1} - T_i^n}{\Delta
        t} $$

        <h3>空間2階微分（中心差分）</h3>

        $$ \frac{\partial^2 T}{\partial x^2} \approx \frac{T_{i+1}^n - 2T_i^n +
        T_{i-1}^n}{(\Delta x)^2} $$
      </section>

      <section>
        <h2>4. 更新式</h2>

        <p>これらを熱伝導方程式に代入すると、次の更新式が得られる。</p>

        $$ T_i^{n+1} = T_i^n + r (T_{i+1}^n - 2T_i^n + T_{i-1}^n) $$ $$ r =
        \frac{\alpha \Delta t}{(\Delta x)^2} $$
      </section>

      <section>
        <h2>5. クーラン条件（安定性条件）</h2>

        <p>
          この陽的差分法が安定に動作するためには、次の条件を満たす必要がある。
        </p>

        $$ r \le \frac{1}{2} $$

        <p>すなわち、</p>

        $$ \Delta t \le \frac{(\Delta x)^2}{2\alpha} $$

        <p>この条件を破ると、温度は数値的に発散し、非物理的な結果になる。</p>
      </section>

      <section>
        <h2>6. シミュレーション</h2>

        <p>
          以下のシミュレーションでは、中央に高温領域を与えた一次元熱伝導問題を
          陽的有限差分法で計算している。
        </p>

        <div class="control">
          dt:
          <input type="number" id="dt_input" value="0.001" step="0.0001" />

          <button id="reset_btn">やり直し</button>
        </div>

        <div class="control">
          Courant 数 r =
          <span id="courant_value">---</span>
          <span id="courant_warning"></span>
        </div>

        <canvas id="canvas" width="600" height="300"></canvas>
      </section>
    </main>

    <script>
      var Module = {
        onRuntimeInitialized: function () {
          const init_c = Module.cwrap("initialize_simulation_c", "void", []);
          const step_c = Module.cwrap("one_step_and_draw", "void", ["number"]);
          const getN = Module.cwrap("get_array_size", "number", []);
          const getPtr = Module.cwrap("get_temperature_data", "number", []);

          // C++ 側パラメータ（合わせておく）
          const alpha = 0.01;
          const L = 1.0;

          init_c();

          const N = getN();
          const dx = L / (N - 1);

          const ptr = getPtr();
          const data = Module.HEAPF64.subarray(ptr / 8, ptr / 8 + N);

          const canvas = document.getElementById("canvas");
          const ctx = canvas.getContext("2d");
          const dtInput = document.getElementById("dt_input");
          const resetBtn = document.getElementById("reset_btn");
          const courantValue = document.getElementById("courant_value");
          const courantWarning = document.getElementById("courant_warning");

          resetBtn.onclick = () => {
            init_c();
          };

          function updateCourant(dt) {
            const r = (alpha * dt) / (dx * dx);
            courantValue.textContent = r.toFixed(4);

            if (r > 0.5) {
              courantValue.style.color = "red";
              courantWarning.textContent = "（不安定）";
              courantWarning.style.color = "red";
            } else {
              courantValue.style.color = "black";
              courantWarning.textContent = "（安定）";
              courantWarning.style.color = "green";
            }
          }

          function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.beginPath();
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;

            const margin = 20;
            const scaleX = canvas.width / (N - 1);
            const scaleY = (canvas.height - 2 * margin) / 100.0;

            for (let i = 0; i < N; i++) {
              const x = i * scaleX;
              const y = canvas.height - margin - data[i] * scaleY;

              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }

            ctx.stroke();
          }

          function loop() {
            const dt = parseFloat(dtInput.value);
            updateCourant(dt);
            step_c(dt);
            draw();
            requestAnimationFrame(loop);
          }

          loop();
        },
      };
    </script>

    <script src="index.js"></script>
  </body>
</html>
